
Создайте Worker, работающий с Flow:

class EventNotificationWorker(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) {
    override suspend fun doWork(): Result {
        val eventDao = // Инициализация вашего DAO
        eventDao.getEventsFlow().collect { events ->
            val currentTime = System.currentTimeMillis()

            events.forEach { event ->
                val eventTime = event.time

                if (eventTime - currentTime <= TimeUnit.DAYS.toMillis(1) &&
                    eventTime - currentTime > 0) {
                    sendNotification("Напоминание о событии завтра!", event)
                }

                if (eventTime - currentTime <= 0) {
                    sendNotification("Сегодня событие!", event)
                }
            }
        }

        return Result.success()
    }

    private fun sendNotification(message: String, event: Event) {
        // Ваш код для отправки уведомления
    }
}


Запланируйте задачу с WorkManager:
kotlin

Copy
val workRequest = PeriodicWorkRequestBuilder<EventNotificationWorker>(1, TimeUnit.DAYS)
    .setInitialDelay(calculateInitialDelay(), TimeUnit.MILLISECONDS)
    .build()

WorkManager.getInstance(context).enqueueUniquePeriodicWork(
    "EventNotificationWork",
    ExistingPeriodicWorkPolicy.REPLACE,
    workRequest
)
Вычислите задержку для запуска в полночь:
kotlin

Copy
private fun calculateInitialDelay(): Long {
    val currentTimeMillis = System.currentTimeMillis()
    val calendar = Calendar.getInstance().apply {
        timeInMillis = currentTimeMillis
        set(Calendar.HOUR_OF_DAY, 0)
        set(Calendar.MINUTE, 0)
        set(Calendar.SECOND, 0)
        set(Calendar.MILLISECOND, 0)

        if (timeInMillis <= currentTimeMillis) {
            add(Calendar.DAY_OF_MONTH, 1)
        }
    }
    return calendar.timeInMillis - currentTimeMillis
}
Пояснения
CoroutineWorker: Использует корутины для работы с Flow.
collect: Слушает изменения в данных событий.
Уведомления: Отправляются за день до события и в день события.
Регистрация
Убедитесь, что ваш Worker зарегистрирован и имеет доступ к базе данных.


Запланируйте выполнение задачи каждый день, например, в полночь.



В чистой архитектуре код для планирования задачи с использованием WorkManager должен находиться в слое, который отвечает за взаимодействие с фреймворками и платформой. Обычно это слой данных или инфраструктуры.

Где размещать код
Слой инфраструктуры:
Создайте класс, отвечающий за планирование задач. Этот класс будет использоваться для настройки WorkManager.
Размещайте код планирования в этом классе.
Используйте DI (например, Hilt):
Внедрите этот класс в нужные части приложения, где требуется настройка задач, например, в ViewModel или UseCase.
Пример класса планировщика задач
kotlin

Copy
class TaskScheduler @Inject constructor(private val context: Context) {

    fun scheduleDailyTask() {
        val workRequest = PeriodicWorkRequestBuilder<EventNotificationWorker>(1, TimeUnit.DAYS)
            .setInitialDelay(calculateInitialDelay(), TimeUnit.MILLISECONDS)
            .build()

        WorkManager.getInstance(context).enqueueUniquePeriodicWork(
            "EventNotificationWork",
            ExistingPeriodicWorkPolicy.REPLACE,
            workRequest
        )
    }

    private fun calculateInitialDelay(): Long {
        val currentTimeMillis = System.currentTimeMillis()
        val calendar = Calendar.getInstance().apply {
            timeInMillis = currentTimeMillis
            set(Calendar.HOUR_OF_DAY, 0)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)

            if (timeInMillis <= currentTimeMillis) {
                add(Calendar.DAY_OF_MONTH, 1)
            }
        }
        return calendar.timeInMillis - currentTimeMillis
    }
}
Использование
В ViewModel или UseCase: Вызывайте scheduleDailyTask() из этих слоев, чтобы запланировать задачу.
Этот подход позволяет изолировать код, связанный с платформой, и делает его более тестируемым и поддерживаемым.